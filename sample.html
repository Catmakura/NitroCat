<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ä¸»è¦Web API + WebGPU ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚° ãƒ‡ãƒ¢</title>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      background: #eef2f7;
      margin: 30px;
      color: #333;
    }
    section {
      background: #fff;
      padding: 20px;
      margin-bottom: 20px;
      border-radius: 12px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }
    h2 {
      border-left: 6px solid #4caf50;
      padding-left: 10px;
      color: #333;
    }
    progress {
      width: 100%;
      height: 20px;
    }
    video {
      width: 100%;
      border-radius: 8px;
      background: #000;
    }
    canvas {
      width: 100%;
      height: 300px;
      border: 2px solid #4caf50;
      border-radius: 8px;
      background: #111;
    }
    .error { color: red; font-weight: bold; }
    .success { color: green; font-weight: bold; }
  </style>
</head>
<body>
  <h1>ğŸŒ Web API + WebGPU ç·åˆãƒ‡ãƒ¢</h1>

  <!-- Battery API -->
  <section id="battery-section">
    <h2>ğŸ”‹ Battery Status API</h2>
    <p>çŠ¶æ…‹: <span id="battery-status">èª­ã¿è¾¼ã¿ä¸­...</span></p>
    <p>ãƒãƒƒãƒ†ãƒªãƒ¼æ®‹é‡: <span id="battery-level">--</span>%</p>
    <p>å……é›»ã¾ã§ã®æ™‚é–“: <span id="charging-time">--</span></p>
    <p>æ”¾é›»ã¾ã§ã®æ™‚é–“: <span id="discharging-time">--</span></p>
    <progress id="battery-progress" value="0" max="100"></progress>
  </section>

  <!-- Geolocation API -->
  <section id="geo-section">
    <h2>ğŸ“ Geolocation API</h2>
    <button id="get-location">ç¾åœ¨åœ°ã‚’å–å¾—</button>
    <p>ç·¯åº¦: <span id="latitude">--</span></p>
    <p>çµŒåº¦: <span id="longitude">--</span></p>
    <p id="geo-status"></p>
  </section>

  <!-- WebRTC API -->
  <section id="webrtc-section">
    <h2>ğŸ¥ WebRTC API (getUserMedia)</h2>
    <button id="start-camera">ã‚«ãƒ¡ãƒ©ã‚’èµ·å‹•</button>
    <video id="camera" autoplay playsinline></video>
    <p id="camera-status"></p>
  </section>

  <!-- sessionStorage API -->
  <section id="storage-section">
    <h2>ğŸ’¾ sessionStorage API</h2>
    <p>
      <input type="text" id="storage-input" placeholder="ä¿å­˜ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›" />
      <button id="save-storage">ä¿å­˜</button>
      <button id="load-storage">èª­ã¿è¾¼ã¿</button>
    </p>
    <p>ä¿å­˜ã•ã‚ŒãŸå€¤: <span id="storage-output">ï¼ˆãªã—ï¼‰</span></p>
  </section>

  <!-- WebGPU API -->
  <section id="webgpu-section">
    <h2>âš™ï¸ WebGPU API + ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°</h2>
    <canvas id="gpuCanvas" width="400" height="300"></canvas>
    <p id="webgpu-status">åˆæœŸåŒ–ä¸­...</p>
  </section>

  <script type="module">
    // ===============================
    // Battery Status API
    // ===============================
    function formatTime(sec) {
      if (sec === Infinity || sec < 0) return "â€•";
      const h = Math.floor(sec / 3600);
      const m = Math.floor((sec % 3600) / 60);
      return h > 0 ? `${h}æ™‚é–“${m}åˆ†` : `${m}åˆ†`;
    }

    if ('getBattery' in navigator) {
      navigator.getBattery().then(battery => {
        const s = id => document.getElementById(id);
        function update() {
          const level = Math.round(battery.level * 100);
          s('battery-level').textContent = level;
          s('battery-progress').value = level;
          s('battery-status').textContent = battery.charging ? "âš¡ å……é›»ä¸­" : "ğŸ”‹ ä½¿ç”¨ä¸­";
          s('charging-time').textContent = formatTime(battery.chargingTime);
          s('discharging-time').textContent = formatTime(battery.dischargingTime);
        }
        update();
        ['chargingchange','levelchange','chargingtimechange','dischargingtimechange']
          .forEach(e => battery.addEventListener(e, update));
      });
    } else {
      document.getElementById("battery-section").innerHTML =
        "<p class='error'>âŒ Battery API ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚</p>";
    }

    // ===============================
    // Geolocation API
    // ===============================
    document.getElementById("get-location").addEventListener("click", () => {
      const status = document.getElementById("geo-status");
      if (!navigator.geolocation) {
        status.textContent = "âŒ Geolocation API ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚";
        return;
      }
      status.textContent = "ğŸ“¡ ç¾åœ¨åœ°ã‚’å–å¾—ä¸­...";
      navigator.geolocation.getCurrentPosition(
        pos => {
          document.getElementById("latitude").textContent = pos.coords.latitude.toFixed(5);
          document.getElementById("longitude").textContent = pos.coords.longitude.toFixed(5);
          status.textContent = "âœ… ç¾åœ¨åœ°ã‚’å–å¾—ã—ã¾ã—ãŸã€‚";
        },
        err => {
          status.textContent = `âŒ ã‚¨ãƒ©ãƒ¼: ${err.message}`;
        }
      );
    });

    // ===============================
    // WebRTC API
    // ===============================
    document.getElementById("start-camera").addEventListener("click", async () => {
      const video = document.getElementById("camera");
      const status = document.getElementById("camera-status");
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;
        status.textContent = "âœ… ã‚«ãƒ¡ãƒ©ã‚’èµ·å‹•ã—ã¾ã—ãŸã€‚";
        status.className = "success";
      } catch (err) {
        status.textContent = "âŒ ã‚«ãƒ¡ãƒ©ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“: " + err.message;
        status.className = "error";
      }
    });

    // ===============================
    // sessionStorage API
    // ===============================
    document.getElementById("save-storage").addEventListener("click", () => {
      const value = document.getElementById("storage-input").value;
      sessionStorage.setItem("demoText", value);
      document.getElementById("storage-output").textContent = value || "ï¼ˆãªã—ï¼‰";
    });
    document.getElementById("load-storage").addEventListener("click", () => {
      const value = sessionStorage.getItem("demoText") || "ï¼ˆãªã—ï¼‰";
      document.getElementById("storage-output").textContent = value;
    });

    // ===============================
    // WebGPU API + Rendering
    // ===============================
    const canvas = document.getElementById("gpuCanvas");
    const status = document.getElementById("webgpu-status");

    if (!navigator.gpu) {
      status.textContent = "âŒ ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ WebGPU ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚";
    } else {
      const adapter = await navigator.gpu.requestAdapter();
      const device = await adapter.requestDevice();
      const context = canvas.getContext("webgpu");
      const format = navigator.gpu.getPreferredCanvasFormat();
      context.configure({ device, format, alphaMode: "premultiplied" });

      const vertices = new Float32Array([
        // X, Y, R, G, B
        -0.5, -0.5, 1, 0, 0,
         0.5, -0.5, 0, 1, 0,
        -0.5,  0.5, 0, 0, 1,
         0.5,  0.5, 1, 1, 0
      ]);
      const vertexBuffer = device.createBuffer({
        size: vertices.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
      });
      device.queue.writeBuffer(vertexBuffer, 0, vertices);

      const shader = `
        struct Output {
          @builtin(position) Position : vec4f,
          @location(0) color : vec3f
        };

        @group(0) @binding(0) var<uniform> time : f32;

        @vertex
        fn vs_main(@location(0) pos : vec2f, @location(1) color : vec3f) -> Output {
          var out : Output;
          let angle = time;
          let rot = mat2x2f(cos(angle), -sin(angle), sin(angle), cos(angle));
          out.Position = vec4f(rot * pos, 0.0, 1.0);
          out.color = color;
          return out;
        }

        @fragment
        fn fs_main(@location(0) color : vec3f) -> @location(0) vec4f {
          return vec4f(color, 1.0);
        }
      `;
      const shaderModule = device.createShaderModule({ code: shader });

      const uniformBuffer = device.createBuffer({
        size: 4,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      });
      const bindGroupLayout = device.createBindGroupLayout({
        entries: [{ binding: 0, visibility: GPUShaderStage.VERTEX, buffer: {} }]
      });
      const bindGroup = device.createBindGroup({
        layout: bindGroupLayout,
        entries: [{ binding: 0, resource: { buffer: uniformBuffer } }]
      });

      const pipeline = device.createRenderPipeline({
        layout: device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),
        vertex: {
          module: shaderModule,
          entryPoint: "vs_main",
          buffers: [{
            arrayStride: 5 * 4,
            attributes: [
              { shaderLocation: 0, offset: 0, format: "float32x2" },
              { shaderLocation: 1, offset: 8, format: "float32x3" }
            ]
          }]
        },
        fragment: {
          module: shaderModule,
          entryPoint: "fs_main",
          targets: [{ format }]
        },
        primitive: { topology: "triangle-strip" }
      });

      // æç”»ãƒ«ãƒ¼ãƒ—ï¼ˆå›è»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
      let start = performance.now();
      function draw() {
        const now = (performance.now() - start) / 1000;
        device.queue.writeBuffer(uniformBuffer, 0, new Float32Array([now]));

        const encoder = device.createCommandEncoder();
        const pass = encoder.beginRenderPass({
          colorAttachments: [{
            view: context.getCurrentTexture().createView(),
            clearValue: { r: 0.1, g: 0.1, b: 0.1, a: 1 },
            loadOp: "clear",
            storeOp: "store"
          }]
        });
        pass.setPipeline(pipeline);
        pass.setBindGroup(0, bindGroup);
        pass.setVertexBuffer(0, vertexBuffer);
        pass.draw(4);
        pass.end();
        device.queue.submit([encoder.finish()]);
        requestAnimationFrame(draw);
      }

      draw();
      status.textContent = "âœ… WebGPU ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å®Ÿè¡Œä¸­ï¼ˆå››è§’å½¢ãŒå›è»¢ã—ã¾ã™ï¼‰";
    }
  </script>
</body>
</html>

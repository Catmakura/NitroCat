<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>WebGPU 高画質 3Dトーラス（マテリアル反射・マウス操作付き）</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  body { background: #101018; color: #ccc; font-family: "Segoe UI", sans-serif; margin: 0; text-align: center; }
  h1 { margin: 10px 0; }
  canvas { display: block; margin: 0 auto; border-radius: 8px; width: 80vw; height: 60vh; border: 2px solid #333; }
  #controls { margin: 10px; }
</style>
</head>
<body>
<h1>⚙️ WebGPU 3Dトーラス（反射ON/OFF & マウス操作）</h1>
<canvas id="gpuCanvas" width="800" height="600"></canvas>
<div id="controls">
  <button id="toggleSpecular">反射: ON</button>
</div>
<p id="status">初期化中...</p>

<script type="module">
const canvas = document.getElementById("gpuCanvas");
const status = document.getElementById("status");
const toggleBtn = document.getElementById("toggleSpecular");

if (!navigator.gpu) { status.textContent = "❌ WebGPU未対応"; throw new Error("WebGPU unsupported"); }

const adapter = await navigator.gpu.requestAdapter();
const device = await adapter.requestDevice();
const context = canvas.getContext("webgpu");
const format = navigator.gpu.getPreferredCanvasFormat();
context.configure({ device, format, alphaMode: "premultiplied" });

let specularEnabled = true;
toggleBtn.onclick = () => { specularEnabled = !specularEnabled; toggleBtn.textContent = `反射: ${specularEnabled?"ON":"OFF"}`; };

// === トーラス生成 ===
function createTorus(R=0.6, r=0.25, segmentsR=64, segmentsr=32){
  const vertices = [];
  for(let i=0;i<=segmentsR;i++){
    const theta = i/segmentsR*2*Math.PI;
    for(let j=0;j<=segmentsr;j++){
      const phi = j/segmentsr*2*Math.PI;
      const x = (R + r*Math.cos(phi))*Math.cos(theta);
      const y = (R + r*Math.cos(phi))*Math.sin(theta);
      const z = r*Math.sin(phi);
      const nx = Math.cos(phi)*Math.cos(theta);
      const ny = Math.cos(phi)*Math.sin(theta);
      const nz = Math.sin(phi);
      vertices.push(x,y,z,nx,ny,nz);
    }
  }
  const indices = [];
  for(let i=0;i<segmentsR;i++){
    for(let j=0;j<segmentsr;j++){
      const a=i*(segmentsr+1)+j;
      const b=a+segmentsr+1;
      indices.push(a,b,a+1,b,b+1,a+1);
    }
  }
  return { vertices:new Float32Array(vertices), indices:new Uint32Array(indices) };
}

const { vertices, indices } = createTorus();
const vertexBuffer = device.createBuffer({ size: vertices.byteLength, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST });
device.queue.writeBuffer(vertexBuffer,0,vertices);
const indexBuffer = device.createBuffer({ size: indices.byteLength, usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST });
device.queue.writeBuffer(indexBuffer,0,indices);

// === Uniform バッファ（MVP + 光源 + specular flag） ===
const uniformBuffer = device.createBuffer({
  size: 64 + 16 + 4, // mvpMatrix + lightDir + specularFlag
  usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
});

// === Shader（Phong + specularオン/オフ） ===
const shaderCode = `
struct Uniforms{
  mvpMatrix: mat4x4<f32>,
  lightDir: vec4<f32>,
  specularFlag: u32
};
@binding(0) @group(0) var<uniform> uniforms: Uniforms;

struct VSOut {
  @builtin(position) Position: vec4<f32>,
  @location(0) normal: vec3<f32>,
  @location(1) pos: vec3<f32>
};

@vertex
fn vs_main(@location(0) position: vec3<f32>, @location(1) normal: vec3<f32>) -> VSOut {
  var out: VSOut;
  out.Position = uniforms.mvpMatrix * vec4<f32>(position,1.0);
  out.normal = normalize(normal);
  out.pos = position;
  return out;
}

@fragment
fn fs_main(@location(0) normal: vec3<f32>, @location(1) pos: vec3<f32>) -> @location(0) vec4<f32> {
  let light = normalize(uniforms.lightDir.xyz);
  let viewDir = normalize(vec3<f32>(0.0,0.0,1.0));
  let diffuse = max(dot(normal,light),0.0);
  var spec: f32 = 0.0;
  if(uniforms.specularFlag==1u){
    let reflectDir = reflect(-light, normal);
    spec = pow(max(dot(viewDir, reflectDir),0.0),32.0);
  }
  let color = vec3<f32>(0.2,0.5,1.0)*diffuse + vec3<f32>(0.05,0.05,0.1) + vec3<f32>(1.0,1.0,1.0)*spec;
  return vec4<f32>(color,1.0);
}
`;

const shaderModule = device.createShaderModule({ code: shaderCode });
const pipeline = device.createRenderPipeline({
  layout:"auto",
  vertex: {
    module: shaderModule,
    entryPoint:"vs_main",
    buffers:[{ arrayStride:24, attributes:[
      {shaderLocation:0,offset:0,format:"float32x3"},
      {shaderLocation:1,offset:12,format:"float32x3"}
    ]}]
  },
  fragment: { module:shaderModule, entryPoint:"fs_main", targets:[{format}] },
  primitive: { topology:"triangle-list", cullMode:"back" },
  depthStencil: { format:"depth24plus", depthWriteEnabled:true, depthCompare:"less" }
});

const depthTexture = device.createTexture({ size:[canvas.width,canvas.height], format:"depth24plus", usage:GPUTextureUsage.RENDER_ATTACHMENT });
const bindGroup = device.createBindGroup({ layout:pipeline.getBindGroupLayout(0), entries:[{binding:0,resource:{buffer:uniformBuffer}}] });

// === マトリクス計算 ===
function mat4Perspective(fov, aspect, near, far){ const f=1/Math.tan(fov/2), nf=1/(near-far); return new Float32Array([f/aspect,0,0,0,0,f,0,0,0,0,(far+near)*nf,-1,0,0,2*far*near*nf,0]); }
function mat4Multiply(a,b){ const out=new Float32Array(16); for(let i=0;i<4;i++)for(let j=0;j<4;j++)out[i*4+j]=a[i*4+0]*b[0*4+j]+a[i*4+1]*b[1*4+j]+a[i*4+2]*b[2*4+j]+a[i*4+3]*b[3*4+j]; return out; }
function mat4RotationY(angle){ const c=Math.cos(angle),s=Math.sin(angle); return new Float32Array([c,0,-s,0,0,1,0,0,s,0,c,0,0,0,0,1]); }
function mat4RotationX(angle){ const c=Math.cos(angle),s=Math.sin(angle); return new Float32Array([1,0,0,0,0,c,-s,0,0,s,c,0,0,0,0,1]); }
function mat4Translation(x,y,z){ const m=new Float32Array(16); m.set([1,0,0,0,0,1,0,0,0,0,1,0,x,y,z,1]); return m; }

// === マウス操作 ===
let rotationX = 0, rotationY = 0, isDragging = false, lastX=0,lastY=0;
canvas.onmousedown = e => { isDragging=true; lastX=e.clientX; lastY=e.clientY; };
canvas.onmouseup = () => { isDragging=false; };
canvas.onmousemove = e => {
  if(isDragging){
    rotationY += (e.clientX - lastX)*0.01;
    rotationX += (e.clientY - lastY)*0.01;
    lastX = e.clientX; lastY = e.clientY;
  }
};

// === 描画ループ ===
function frame(){
  const aspect = canvas.width/canvas.height;
  const proj = mat4Perspective(Math.PI/4, aspect,0.1,100);
  const view = mat4Translation(0,0,-2.5);
  const rotX = mat4RotationX(rotationX);
  const rotY = mat4RotationY(rotationY);
  const model = mat4Multiply(rotY,rotX);
  const mvp = mat4Multiply(proj,mat4Multiply(view,model));

  const light = new Float32Array([0.5,0.5,1.0,0.0]);
  device.queue.writeBuffer(uniformBuffer,0,mvp);
  device.queue.writeBuffer(uniformBuffer,64,light);
  device.queue.writeBuffer(uniformBuffer,80,new Uint32Array([specularEnabled?1:0]));

  const encoder = device.createCommandEncoder();
  const pass = encoder.beginRenderPass({
    colorAttachments:[{view:context.getCurrentTexture().createView(), clearValue:{r:0.05,g:0.07,b:0.1,a:1.0}, loadOp:"clear", storeOp:"store"}],
    depthStencilAttachment:{view:depthTexture.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}
  });

  pass.setPipeline(pipeline);
  pass.setBindGroup(0,bindGroup);
  pass.setVertexBuffer(0,vertexBuffer);
  pass.setIndexBuffer(indexBuffer,"uint32");
  pass.drawIndexed(indices.length);
  pass.end();

  device.queue.submit([encoder.finish()]);
  requestAnimationFrame(frame);
}

frame();
status.textContent = "✅ 高画質WebGPUレンダリング中（マウスで回転可, 反射ON/OFF可能）";
</script>
</body>
</html>
